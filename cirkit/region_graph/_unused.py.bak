import networkx as nx
import numpy as np


def check_partition(scope: Collection[int], partition: Collection[Collection[int]]) -> bool:
    """
    Checks if partition represents a partition of scope.

    :param scope: some iterable representing a set of objects.
    :param partition: some iterable of iterables, representing a set of sets.
    :return: True of partition is a partition of scope
                 i) union over partition is scope
                 ii) sets in partition are non-overlapping
    """
    union = set().union(*partition)
    non_overlapping = len(union) == sum(len(p) for p in partition)
    return set(scope) == union and non_overlapping


def check_graph(graph: nx.DiGraph) -> bool:
    """
    Check if a graph satisfies our requirements for PC graphs.

    :param graph:
    :return: True/False (bool), string description
    """

    contains_only_pc_nodes = all(isinstance(n, (RegionNode, PartitionNode)) for n in graph.nodes())

    is_dag = nx.is_directed_acyclic_graph(graph)  # TODO: typing
    is_connected = nx.is_connected(graph.to_undirected())

    sums = get_sums(graph)
    products = get_products(graph)

    products_one_parents = all(len(list(graph.predecessors(p))) == 1 for p in products)
    products_two_children = all(len(list(graph.successors(p))) == 2 for p in products)

    sum_to_products = all(
        all(isinstance(p, PartitionNode) for p in graph.successors(s)) for s in sums
    )
    product_to_dist = all(
        all(isinstance(s, RegionNode) for s in graph.successors(p)) for p in products
    )
    alternating = sum_to_products and product_to_dist

    # TODO: p type
    smooth = all(all(p.scope == s.scope for p in graph.successors(s)) for s in sums)
    decomposable = all(
        check_partition(p.scope, [s.scope for s in graph.successors(p)]) for p in products
    )

    msg = ""
    if not contains_only_pc_nodes:
        msg += "Graph does not only contain DistributionVector or Product nodes.\n"
    if not is_dag:
        msg += "Graph not acyclic.\n"
    if not is_connected:
        msg += "Graph not connected.\n"
    if not products_one_parents:
        msg += "Products do not have exactly one parent.\n"
    if not products_two_children:
        msg += "Products do not have exactly two children.\n"
    if not alternating:
        msg += "Graph not alternating.\n"
    if not smooth:
        msg += "Graph is not smooth.\n"
    if not decomposable:
        msg += "Graph is not decomposable.\n"

    if msg:
        raise Exception(msg)

    return True


def plot_graph(graph):
    """
    Plots the PC graph.

    :param graph: the PC graph (DiGraph)
    :return: None
    """
    pos = {}
    layers = topological_layers(graph)
    for i, layer in enumerate(layers):
        for j, item in enumerate(layer):
            pos[item] = np.array([float(j) - 0.25 + 0.5 * np.random.rand(), float(i)])

    distributions = [n for n in graph.nodes if type(n) == RegionNode]
    products = [n for n in graph.nodes if type(n) == PartitionNode]
    node_sizes = [3 + 10 * i for i in range(len(graph))]

    nx.draw_networkx_nodes(graph, pos, distributions, node_shape="p")
    nx.draw_networkx_nodes(graph, pos, products, node_shape="^")
    nx.draw_networkx_edges(graph, pos, node_size=node_sizes, arrowstyle="->", arrowsize=10, width=2)


def example1():
    import matplotlib.pyplot as plt

    graph = random_binary_trees(7, 2, 3)
    _, msg = check_graph(graph)
    print(msg)

    plt.figure(1)
    plt.clf()
    plt.title("Random binary tree (RAT-SPN)")
    plot_graph(graph)
    plt.show()

    print()

    graph = poon_domingos_structure((3, 3), delta=1, max_split_depth=None)
    _, msg = check_graph(graph)
    print(msg)
    plt.figure(1)
    plt.clf()
    plt.title("Poon-Domingos Structure")
    plot_graph(graph)
    plt.show()


def example2():
    graph = quad_tree_graph(28, 28)
    serialization.serialize(graph, "simple_image_graph.json")


def example3():
    structure = "quad_tree_dec"

    if structure == "quad_tree":
        graph = quad_tree_graph(width=28, height=28, stdec=False)
        serialize(graph, "quad_tree_28_28.json")
    elif structure == "quad_tree_dec":
        graph = quad_tree_graph(width=28, height=28, stdec=True)
        serialize(graph, "quad_tree_stdec_28_28.json")
    elif structure == "poon_domingos":
        pd_num_pieces = [4]
        pd_delta = [[28 / d, 28 / d] for d in pd_num_pieces]
        graph = poon_domingos_structure((28, 28), pd_delta)
        serialize(graph, "poon_domingos_28_28.json")
    else:
        raise AssertionError("Unknown region graph")
